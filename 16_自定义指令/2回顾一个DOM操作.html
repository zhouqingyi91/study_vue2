<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 
        需求1: 定义一个v-big指令, 和v-text功能类似, 但会把绑定的数值放大10倍
        需求2: 定义一个v-fbind指令, 和v-bind功能类似, 但可以让其所绑定的input元素默认获取焦点

        自定义指令总结:
        1 - 定义语法:
            1 - 局部指令:
                new Vue({directives:{指令名:配置对象}})
                或
                new Vue({directives:{指令名:回调函数}})
            2 - 全局指令:
                Vue.directive(指令名, 配置对象)
                或
                Vue.directive(指令名, 回调函数)
        2 - 配置对象中常用的3个回调
            1 - bind: 指令与元素成功绑定时调用
            2 - inserted: 指令所在元素被插入页面时调用
            3 - update: 指令所在模板结构被重新解析时调用
        3 - 备注:
            1 - 指令定义时不加v-, 但使用时要加v-
            2 - 指令名如果是多个单词, 要使用kebab-case命名方式, 不要使用驼峰命名法
            3 - 如果自定义指令用的是回调函数, 那该函数的回调就是在bind和update阶段被调用

     -->
     <div id="root">
        <h2>当前的n值是:{{n}}</h2>
        <h2>放大10倍后的n值是: <span v-big="n"></span></h2>
        <button @click="n++">n+1</button>
        <input type="text"  v-fbind2="n">
     </div>
</body>

<script type="text/javascript">
    // 全局自定义指令
    Vue.directive('fbind2', {
        // 指令与元素成功绑定时(一上来)
        bind(element, binding){
            element.value = binding.value;
        },
        // 指令所在元素被插入页面时
        inserted(element, binding){
            element.focus();
        },
        // 指令所在的模板被重新解析时
        update(element, binding){
            element.value = binding.value;
        },
    })

    const vm = new Vue({
        el:'#root',
        data:{
            n: 1,
        },
        directives: { // directives里面的this是window
            /* 
            big函数何时会被调用?
            1 - 指令与元素成功绑定时(一上来)
            2 - 指令所在的模板被重新解析时
            */
            big(element, binding) {
                console.log(element, binding.value);
                element.innerText = binding.value * 10;
            },
            fbind: {
                // 指令与元素成功绑定时(一上来)
                bind(element, binding){
                    element.value = binding.value;
                },
                // 指令所在元素被插入页面时
                inserted(element, binding){
                    element.focus();
                },
                // 指令所在的模板被重新解析时
                update(element, binding){
                    element.value = binding.value;
                },
            }
        }
    })
</script>
</html>